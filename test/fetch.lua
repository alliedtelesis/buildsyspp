require('buildsys')

--[[
Fetch an upstream tarball

- package, the name of the package
- version, the version of the package to use
- url, the full url to download the tarball from
    (default: site .. file)
- sourcedir, the directory the tarball will extract to
    (default: package .. '-' version)
- file, file name that is fetched/to be extracted
    (default: package .. '-' .. version .. ext)
- site, everything before the file in the URL
- ext, file extension used (i.e. '.tar.gz' or '.tar.bz2')
- dist, source includes autogenerated build system (default: true)
]]
function tarball(args)
    local bd = builddir()
    local sourcedir = args.sourcedir
    if sourcedir == nil then
        sourcedir = args.package .. '-' .. args.version
    end

    local url = args.url
    if (url == nil) then
        url = args.site .. sourcedir .. args.ext
    end

    local file = args.file
    if (args.file == nil) then
        file = sourcedir .. args.ext
    end

    local dist = true
    if (args.dist ~= nil) then
        dist = args.dist
    end

    bd:fetch(url, 'dl')
    bd:extract('dl/' .. file)

    -- Create fetch object
    local fetch = {
        _sourcedir = sourcedir,
        _dist = dist,
    }
    fetch.sourcedir = function(fetch)
        return fetch._sourcedir
    end
    fetch.dist = function(fetch)
        return fetch._dist
    end

    return fetch
end

--[[
Fetch a git repository

- package, the name of the package
- url, the git url to fetch from
- head, the git branch/tag to checkout
- dist, source includes autogenerated build system (default: false)
]]
function git(args)
    local bd = builddir()
    local sourcedir = args.package

    local dist = false
    if (args.dist ~= nil) then
        dist = args.dist
    end

    bd:fetch(args.url, 'git', args.head, args.package)

    -- Create fetch object
    local fetch = {
        _sourcedir = sourcedir,
        _dist = dist,
    }
    fetch.sourcedir = function(fetch)
        return fetch._sourcedir
    end
    fetch.dist = function(fetch)
        return fetch._dist
    end

    return fetch
end

--[[
Copygit a local git repo

- package, the name of the package
- url, the relative path to the repo
]]
function copygit(args)
    local bd = builddir()
    local sourcedir = args.package
    local dist = false

    bd:fetch(args.url, 'copygit')

    -- Create fetch object
    local fetch = {
        _sourcedir = sourcedir,
        _dist = dist,
    }
    fetch.sourcedir = function(fetch)
        return fetch._sourcedir
    end
    fetch.dist = function(fetch)
        return fetch._dist
    end

    return fetch
end

--[[
Fetch an upstream tarball, and optionally fallback to git

- package, the name of the package
- version, the version of the package to use
- url, the full url to download the tarball from
    (default: site .. file)
- file, file name that is fetched/to be extracted
    (default: package .. '-' .. version .. ext)
- site, everything before the version in the URL
- ext, file extension used (i.e. '.tar.gz' or '.tar.bz2')
- dist, source includes autogenerated build system (optional)

If version is 'git':

- git_url, the git url to fetch from
- git_head, the git branch/tag to checkout
]]
function tarball_or_git(args)
    local fetch

    if (args.version == 'git') then
        fetch = git {
            package = args.package,
            url = args.git_url,
            head = args.git_head,
            dist = args.dist,
        }
    else
        fetch = tarball {
            package = args.package,
            version = args.version,
            url = args.url,
            file = args.file,
            site = args.site,
            ext = args.ext,
            dist = args.dist,
        }
    end

    return fetch
end


function find_in_string(string,search,start_at)
    local start,finish = string:find(search,start_at)
    if start == nil then
        return nil
    end
    local found = string:sub(start,finish)

    while found ~= search do
        start,finish = string:find(search,start+1)
        if start == nil then
            return nil
        end
        found = string:sub(start,finish)
    end

    return start
end

--[[
Fetch from a url, either http or git or a relative path

- package, the name of the package

- url, the full download location, supported formats:
-- git urls, these can optionally have # then a git ref-spec to checkout on the end
--- git://git.site/package.git#ref-spec
--- ssh://git.site/path/to/package.git#ref-spec
--- http://github.com/alliedtelesis/apteryx.git#ref-spec
-- http/https tarball download urls
--- http://site/path/package-version.tar.gz
-- copygit urls
--- ../package
]]
function fetch_url(args)
    local fetch = nil
    local url = args.url
    local version = nil

    if (url:find("git:") == 1 or url:find("ssh:") == 1 or find_in_string(url, '.git')) then
        local hashstart,_ = url:find("#")
        local giturl = url
        local githead = 'origin/master'
        version = 'git'
        if hashstart ~= nil then
            giturl = url:sub(1,hashstart-1)
            githead = url:sub(hashstart+1)
        end
        fetch = git {
            package = args.package,
            url = giturl,
            head = githead,
        }
    end

    if (fetch == nil and (url:find("http") == 1 or url:find("ftp:") == 1)) then
        local slash,_ = url:find("/")
        local lastslash
        while slash do
            lastslash = slash
            slash,_ = url:find("/", lastslash+1)
        end
        extensions = {'-src', '.src', '.tar', '.tgz', '.tbz2', '.txz', '.zip'}
        for _,ext in pairs(extensions) do
            extstart = find_in_string(url, ext, lastslash)
            if extstart ~= nil then
                break
            end
        end
        local sourcedir = url:sub(lastslash+1, extstart-1)
        local ext = url:sub(extstart)
        local dash = sourcedir:find("-")
        version = ""
        if dash ~= nil then
            version = sourcedir:sub(dash+1)
        end
        fetch = tarball {
            package = args.package,
            url = url,
            sourcedir = sourcedir,
            ext = ext,
        }
    end

    if fetch == nil then
        fetch = copygit {
            package = args.package,
            url = url,
        }
        version = 'git'
    end

    fetch.version = function()
        return version
    end

    return fetch
end

--[[
- fetch, the fetch instance to patch
- patches, a list of patches to apply
- patch_level, patch level to use, defaults to 1
]]
function fetch_apply_patches(args)
    local fetch = args.fetch
    local bd = builddir()
    local patch_level = args.patch_level
    if (patch_level == nil) then
        patch_level = '1'
    end

    for i, p in pairs(args.patches) do
        bd:patch(fetch:sourcedir(), patch_level, {fetch:sourcedir() .. '-' .. p .. '.patch'})
    end

    return fetch
end
